#!/usr/bin/env bash

set -eu
set -o pipefail
shopt -s nullglob

PLATFORM_UNAME=$(uname -s)
REQUIRED_FILENAME="core"
LOGBT_VERSION="v2.0.0"
BASE_CORE_DIRECTORY=/tmp/logbt-coredumps

if [[ ${PLATFORM_UNAME} == "Linux" ]]; then
  REQUIRED_PATTERN="${REQUIRED_FILENAME}.%p.%E"
  DEBUGGER="gdb"
elif [[ ${PLATFORM_UNAME} == "Darwin" ]]; then
  # Recommend running with the following setting to only show crashes
  # in the notification center
  # defaults write com.apple.CrashReporter UseUNC 1
  REQUIRED_PATTERN="${REQUIRED_FILENAME}.%P"
  DEBUGGER="lldb"
else
  error "Unsupported platform: ${PLATFORM_UNAME}"
fi

function error() {
  >&2 echo "$@"
  exit 1
}

function process_core() {
  local program=${1}
  local corefile=${2}
  local debugger=${3}
  if [[ ${debugger} =~ "lldb" ]]; then
    lldb --core ${corefile} --batch -o "thread backtrace all" -o "quit"
  else
    gdb ${program} --core ${corefile} -ex "set pagination 0" -ex "thread apply all bt" --batch
  fi
  # note: on OS X the -f avoids a hang on prompt "remove write-protected regular file?"
  rm -f ${corefile}
}

function find_core_by_pid() {
  local code=${1}
  local program=${2}
  local core_directory=${3}
  local debugger=${4}
  if [[ ${PLATFORM_UNAME} == "Darwin" ]]; then
    local single_corefile="${core_directory}/${REQUIRED_FILENAME}.${CHILD_PID}"
    if [ -e ${single_corefile} ]; then
      echo "Found corefile at ${single_corefile}"
      process_core ${program} ${single_corefile} ${debugger}
    else
      if [[ ${code} != 0 ]]; then
          echo "No corefile found at ${single_corefile}"
      fi
    fi
  else
    local SEARCH_PATTERN_BY_PID="${REQUIRED_FILENAME}.${CHILD_PID}.*"
    local hit=false
    for corefile in ${core_directory}/${SEARCH_PATTERN_BY_PID}; do
      echo "Found corefile at ${corefile}"
      # extract program name from corefile
      filename=$(basename "${corefile}")
      binary_program=/$(echo ${filename##*.\!} | tr "!" "/")
      process_core ${binary_program} ${corefile} ${debugger}
      hit=true
    done
    if [[ ${hit} == false ]] && [[ ${code} != 0 ]]; then
        echo "No corefile found at ${core_directory}/${SEARCH_PATTERN_BY_PID}"
    fi
  fi  
}

function find_remaining_cores() {
  local code=${1}
  local program=${2}
  local core_directory=${3}
  local debugger=${4}
  local SEARCH_PATTERN_NON_TRACKED="${REQUIRED_FILENAME}.*"
  local hit=false
  for corefile in ${core_directory}/${SEARCH_PATTERN_NON_TRACKED}; do
    echo "Found corefile (non-tracked) at ${corefile}"
    hit=true
  done
  if [[ ${code} != 0 ]]; then
    if [[ ${hit} == true ]]; then
      echo "Processing cores..."
    fi
    for corefile in ${core_directory}/${SEARCH_PATTERN_NON_TRACKED}; do
      # below two lines are linux specific, but harmless to run on osx
      filename=$(basename "${corefile}")
      binary_program=/$(echo ${filename##*.\!} | tr "!" "/")
      process_core ${binary_program} ${corefile} ${debugger}
    done
  else
    if [[ ${hit} == true ]]; then
      echo "Skipping processing cores..."
    fi
  fi  
}

function backtrace {
  local code=$?
  local program=${1}
  local core_directory=${2}
  local debugger=${3}
  echo "${program} exited with code:${code}"
  find_core_by_pid ${code} ${program} ${core_directory} ${debugger}
  find_remaining_cores ${code} ${program} ${core_directory} ${debugger}
  exit $code
}

function warn_on_existing_cores() {
  local core_directory=${1}
  local SEARCH_PATTERN_NON_TRACKED="${REQUIRED_FILENAME}.*"
  for corefile in ${core_directory}/${SEARCH_PATTERN_NON_TRACKED}; do
    echo "WARNING: Found corefile (existing) at ${corefile}"
  done
}

function error_on_existing_cores() {
  local core_directory=${1}
  local SEARCH_PATTERN_NON_TRACKED="${REQUIRED_FILENAME}.*"
  for corefile in ${core_directory}/${SEARCH_PATTERN_NON_TRACKED}; do
    error "Error: Found corefile (unexpected) at ${corefile}"
  done  
}

function ensure_directory_is_writeable() {
  # ensure we can write to the directory, otherwise
  # core files might not be able to be written
  WRITE_RETURN=0
  touch ${core_directory}/test.txt || WRITE_RETURN=$?
  if [[ ${WRITE_RETURN} != 0 ]]; then
    error "Permissions problem: unable to write to ${core_directory} (exited with ${WRITE_RETURN})"
  else
    # cleanup from test
    rm ${core_directory}/test.txt
  fi  
}

function get_target_core_pattern() {
  echo ${BASE_CORE_DIRECTORY}/${REQUIRED_PATTERN}
}

function get_core_pattern() {
  if [[ ${PLATFORM_UNAME} == "Linux" ]]; then
    local core_pattern=$(cat /proc/sys/kernel/core_pattern)
  elif [[ ${PLATFORM_UNAME} == "Darwin" ]]; then
    # Recommend running with the following setting to only show crashes
    # in the notification center
    # defaults write com.apple.CrashReporter UseUNC 1
    local core_pattern=$(sysctl -n kern.corefile)
  fi
  echo ${core_pattern}
}

function validate_core_pattern() {
  local core_pattern=${1}
  if [[ ! ${core_pattern} =~ ${REQUIRED_PATTERN} ]]; then
    error "unexpected core_pattern: ${core_pattern}"
  fi  
}
function launch_and_wait() {

  local core_pattern=$(get_core_pattern)
  validate_core_pattern ${core_pattern}

  local core_directory=$(dirname ${core_pattern})
  echo "Using corefile location: ${core_directory}"
  echo "Using core_pattern: $(basename ${core_pattern})"

  # ensure we have a debugger installed
  if ! which ${DEBUGGER} > /dev/null; then
    error "Could not find required command '${DEBUGGER}'"
  fi

  if [[ ! -d ${core_directory} ]]; then
    echo "Creating directory for core files at '${core_directory}'"
    mkdir -p -m a+w ${core_directory}
  fi

  ensure_directory_is_writeable ${core_directory}

  warn_on_existing_cores ${core_directory}

  # Hook up function to run when logbt exits
  trap "backtrace $1 ${core_directory} ${DEBUGGER}" EXIT

  # Enable corefile generation
  ulimit -c unlimited

  # Run the child process in a background process
  # in order to get the PID
  $* & export CHILD_PID=$!

  # Keep logbt running as long as the child is running
  # to be able to hook into a potential crash
  wait ${CHILD_PID}  
}

function setup_and_exit() {
  local settable_core_pattern=$(get_target_core_pattern)
  if [[ ${PLATFORM_UNAME} == "Linux" ]]; then
    echo "Setting $(cat /proc/sys/kernel/core_pattern) -> ${settable_core_pattern}"
    echo "${settable_core_pattern}" > /writable-proc/sys/kernel/core_pattern
  elif [[ ${PLATFORM_UNAME} == "Darwin" ]]; then
    echo "Setting $(sysctl -n kern.corefile) -> ${settable_core_pattern}"
    sysctl kern.corefile=${settable_core_pattern}
  fi

  local core_pattern=$(get_core_pattern)
  validate_core_pattern ${core_pattern}
  local core_directory=$(dirname ${core_pattern})

  if [[ ! -d ${core_directory} ]]; then
    echo "Creating directory for core files at '${core_directory}'"
    mkdir -p -m a+w ${core_directory}
  fi

  error_on_existing_cores ${core_directory}

  exit 0

}

function test_and_exit() {
  ulimit -c unlimited
  # note: this will only create a corefile on osx with bash 4.x (not the apple 3.x)
  # create a program that crashes itself
  echo '#!/usr/bin/env bash' > /tmp/crasher.sh
  echo 'kill -SIGSEGV $$' >> /tmp/crasher.sh
  chmod +x /tmp/crasher.sh
  # run it in logbt
  RETURN=0
  ${BASH_SOURCE} --watch /tmp/crasher.sh >/tmp/logbt-stdout 2>/tmp/logbt-stderr || RETURN=$?
  if [[ ${RETURN} != 139 ]] || [[ ! $(cat /tmp/logbt-stdout) =~ "Found corefile at" ]]; then
    cat /tmp/logbt-stdout
    cat /tmp/logbt-stderr
    error "Expected return code of 139 and a corefile to be generated"
  fi
  if [[ ! $(cat /tmp/logbt-stdout) =~ "Found corefile at" ]]; then
    cat /tmp/logbt-stdout
    cat /tmp/logbt-stderr
    error "Expected a corefile to be generated"
  fi
  if [[ ! $(cat /tmp/logbt-stderr) =~ "core dumped" ]]; then
    cat /tmp/logbt-stdout
    cat /tmp/logbt-stderr
    error "Expected stderr to contain 'core dumped'"
  fi
  echo "Success"
  # cleanup
  rm /tmp/logbt-stderr
  rm /tmp/logbt-stdout
  rm /tmp/crasher.sh

  exit 0

}

function usage() {
  >&2 echo "Usage for logbt:"
  >&2 echo ""
  >&2 echo "Setup logbt (requires root privileges):"
  >&2 echo ""
  >&2 echo "$ sudo logbt --setup"
  >&2 echo ""
  >&2 echo "Launch another program with logbt:"
  >&2 echo ""
  >&2 echo "$ logbt ./program"
  >&2 echo ""
  >&2 echo "Test logbt is functioning"
  >&2 echo ""
  >&2 echo "$ logbt --test"
  >&2 echo ""
  >&2 echo "Error: Please either pass the path to a program to run or a command (--test, --setup, --version)"
  exit 1
}

function get_version() {
  echo ${LOGBT_VERSION}
  exit 0
}

if [[ ! ${1:-} ]]; then
  usage
fi

for i in "$@"
do
case $i in
    --watch)
    if [[ ! ${2:-} ]]; then
      usage
    fi
    shift
    launch_and_wait $@
    ;;
    --setup)
    setup_and_exit
    shift
    ;;
    --test)
    test_and_exit
    shift
    ;;
    --current-pattern)
    get_core_pattern
    exit 0
    ;;
    --target-pattern)
    get_target_core_pattern
    exit 0
    ;;
    -v | --version)
    get_version
    shift
    ;;
    -h | --help)
    usage
    shift
    ;;
    *)
esac
done
